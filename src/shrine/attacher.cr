# frozen_string_literal: true

class Shrine
  # Core class that handles attaching files. It uses Shrine and
  # Shrine::UploadedFile objects internally.
  class Attacher
    # @shrine_class = ::Shrine
    # Returns the Shrine class that this attacher class is namespaced
    # under.
    class_property shrine_class : Shrine.class = Shrine

    module ClassMethods

      # Initializes the attacher from a data hash generated from `Attacher#data`.
      #
      #     attacher = Attacher.from_data({ "id" => "...", "storage" => "...", "metadata" => { ... } })
      #     attacher.file #=> #<Shrine::UploadedFile>
      def from_data(data, **options)
        attacher = new(**options)
        attacher.load_data(data)
        attacher
      end
    end

    module InstanceMethods
      # Returns the attached uploaded file.
      property file : Shrine::UploadedFile?

      # Returns options that are automatically forwarded to the uploader.
      # Can be modified with additional data.
      getter :context

      getter :cache_key
      getter :store_key

      @previous : Shrine::Attacher?

      # Initializes the attached file, temporary and permanent storage.
      def initialize(@file : Shrine::UploadedFile? = nil, @cache_key : String = "cache", @store_key : String = "store")
        # @file = file
        # @cache = cache
        # @store = store
        @context = Hash(String, String).new
      end

      # Calls #attach_cached, but skips if value is an empty string (this is
      # useful when the uploaded file comes from form fields). Forwards any
      # additional options to #attach_cached.
      #
      #     attacher.assign(File.open(...))
      #     attacher.assign(File.open(...), metadata: { "foo" => "bar" })
      #     attacher.assign('{"id":"...","storage":"cache","metadata":{...}}')
      #     attacher.assign({ "id" => "...", "storage" => "cache", "metadata" => {} })
      #
      #     # ignores the assignment when a blank string is given
      #     attacher.assign("")
      def assign(value : IO?, **options)
        # return if value == "" # skip empty hidden field

        attach_cached(value, **options)
      end

      # Sets an existing cached file, or uploads an IO object to temporary
      # storage and sets it via #attach. Forwards any additional options to
      # #attach.
      #
      #     # upload file to temporary storage and set the uploaded file.
      #     attacher.attach_cached(File.open(...))
      #
      #     # foward additional options to the uploader
      #     attacher.attach_cached(File.open(...), metadata: { "foo" => "bar" })
      #
      #     # sets an existing cached file from JSON data
      #     attacher.attach_cached('{"id":"...","storage":"cache","metadata":{...}}')
      #
      #     # sets an existing cached file from Hash data
      #     attacher.attach_cached({ "id" => "...", "storage" => "cache", "metadata" => {} })
      def attach_cached(value : IO?, **options)
        if value.is_a?(String) || value.is_a?(Hash)
          change(cached(value, **options))
        else
          attach(value, **options.merge(storage: cache_key, action: :cache))
        end
      end

      # Uploads given IO object and changes the uploaded file.
      #
      #     # uploads the file to permanent storage
      #     attacher.attach(io)
      #
      #     # uploads the file to specified storage
      #     attacher.attach(io, storage: :other_store)
      #
      #     # forwards additional options to the uploader
      #     attacher.attach(io, upload_options: { acl: "public-read" }, metadata: { "foo" => "bar" })
      #
      #     # removes the attachment
      #     attacher.attach(nil)
      def attach(io : IO?, storage = store_key, **options)
        file = upload(io, storage, **options) if io

        change(file)
      end


      # Delegates to `Shrine.upload`, passing the #context.
      #
      #     # upload file to specified storage
      #     attacher.upload(io, "store") #=> #<Shrine::UploadedFile>
      #
      #     # pass additional options for the uploader
      #     attacher.upload(io, "store", metadata: { "foo" => "bar" })
      def upload(io : IO?, storage = store_key, **options)
        # shrine_class.upload(io, storage, **context, **options)
        shrine_class.upload(io, storage, **options)
      end

      # Loads the uploaded file from data generated by `Attacher#data`.
      #
      #     attacher.file #=> nil
      #     attacher.load_data({ "id" => "...", "storage" => "...", "metadata" => { ... } })
      #     attacher.file #=> #<Shrine::UploadedFile>
      def load_data(data)
        @file = uploaded_file(data) if data
      end

      # Sets the uploaded file with dirty tracking, and runs validations.
      #
      #     attacher.change(uploaded_file)
      #     attacher.file #=> #<Shrine::UploadedFile>
      #     attacher.changed? #=> true
      def change(file : Shrine::UploadedFile?) : Shrine::UploadedFile?
        @previous = dup unless @file == file
        set(file)
      end

      # Sets the uploaded file.
      #
      #     attacher.set(uploaded_file)
      #     attacher.file #=> #<Shrine::UploadedFile>
      #     attacher.changed? #=> false
      def set(file : Shrine::UploadedFile?) : Shrine::UploadedFile?
        @file = file
      end

      # Returns the attached file.
      #
      #     # when a file is attached
      #     attacher.get #=> #<Shrine::UploadedFile>
      #
      #     # when no file is attached
      #     attacher.get #=> nil
      def get
        file
      end

      # Returns whether a file is attached.
      #
      #     attacher.attach(io)
      #     attacher.attached? #=> true
      #
      #     attacher.attach(nil)
      #     attacher.attached? #=> false
      def attached?
        !!file
      end

      # Converts JSON or Hash data into a Shrine::UploadedFile object.
      #
      #     attacher.uploaded_file('{"id":"...","storage":"...","metadata":{...}}')
      #     #=> #<Shrine::UploadedFile ...>
      #
      #     attacher.uploaded_file({ "id" => "...", "storage" => "...", "metadata" => {} })
      #     #=> #<Shrine::UploadedFile ...>
      def uploaded_file(value)
        shrine_class.uploaded_file(value)
      end

      # Returns the Shrine class that this attacher's class is namespaced
      # under.
      def shrine_class
        self.class.shrine_class
      end
    end

    extend ClassMethods
    include InstanceMethods
  end
end
